присаивание однобайтовой переменной целочисленной
int<-byte
OFFSET L0
push OFFSET b_examp+1
pop eax
pop ebx
mov ebx,[ebx]
mov cl, bl
mov ebx, 0
mov bl, cl
mov dword ptr [eax],ebx
mov eax, [dword ptr b_examp+1]
byte<-byte
pop eax
pop ebx
mov ebx,[ebx]
mov cl,bl
mov ebx, 0
mov bl,cl
mov byte ptr [eax],bl


.586 
 .MODEL FLAT, STDCALL 
 includelib kernel32.lib 
 includelib user32.lib 
 includelib libucrt.lib 
 ExitProcess PROTO: DWORD 
MessageBoxA PROTO : DWORD, : DWORD, : DWORD, : DWORD
.STACK 4096 
.DATA
MB_OK	EQU	0 
message	db	'Произошла ошибка во время выполнения!'
caption	db	'Ошибка в строке: '
MB_ICONERROR	EQU	16 
current_string	 DWORD	 0

;VARS
stk_examp	DWORD	?
b_examp	db	2,4 dup(0)
stk_main	DWORD	?
str_main	db	7,3,3*1 dup(0)
t_main	db	1,0
arr_main	db	2,3,3*4 dup(0)


L0	db	1,5
L1	db	1,3
L3	db	'hello',0
L4	db	1,2
L6	db	'hello world',0
L7	db	1,10
L8	db	1,15
L9	db	1,0
L10	db	1,246
L11	db	1,0
L12	db	2,244,1,0,0



.CODE
int_to_char PROC uses eax ebx ecx edi esi, 
 pstr		: dword, 
 intfield : sdword 
 
 mov edi, pstr 
 mov esi, 0 
 mov eax, intfield 
 cdq 
 test eax, eax 
 mov ebx, 10 
 idiv ebx 
 jns plus 
 neg eax 
 neg edx 
 mov cl, '-' 
 mov [edi], cl 
 inc edi 
 
 plus: 
 push dx 
 inc esi 
 test eax, eax 
 jz fin 
 cdq 
 idiv ebx 
 jmp plus 
 
 fin: 
 mov ecx, esi 
 
 write: 
 pop bx 
 add bl, '0' 
 mov [edi], bl 
 inc edi 
 loop write 
 mov byte ptr [edi], 0 ; Добавление нулевого символа в конец строки 
 ret 
 
 int_to_char ENDP
 showErrorMessageBox PROC 
 PUSH MB_OK + MB_ICONERROR 
 PUSH OFFSET message 
 PUSH OFFSET caption 
 PUSH 0 
 call MessageBoxA 
 push 0 
 call ExitProcess 
 showErrorMessageBox ENDP

 Assign PROC type1:ptr byte, var1:ptr byte, type2:ptr byte, var2:ptr byte
 START:
 mov eax, type1
 mov al,[eax]
 mov ebx,type2
 mov bl,[ebx]
 cmp al,bl
 jne not_equal

 not_equal:
 cmp al, 2
 jne callError
 cmp bl,1
 jne callError
;int<-byte
 mov eax,dword ptr var1
 mov ebx,0
 mov ebx,var2
 mov ebx,[ebx]
 mov cl ,bl
 mov ebx,0
 mov bl,cl
 mov dword ptr [eax],ebx
 
 mov eax,0
 mov ebx,0
 ret
 
 Assign ENDP
 callError:
 add current_string, 1
	INVOKE int_to_char, OFFSET caption+16, current_string
	call showErrorMessageBox
main PROC
START:

push OFFSET b_examp+1
push OFFSET b_examp
push OFFSET L0+1
push OFFSET L0
call Assign
push - 1
call ExitProcess
main ENDP
end main

Assign PROC type1:ptr byte, var1:ptr byte, type2:ptr byte, var2:ptr byte
START:
mov eax, type1
mov al, [eax]
mov ebx, type2
mov bl, [ebx]
cmp al, bl
jne not_equal
cmp al,1
jne go_int
mov eax, var1
mov ebx, 0
mov ebx, var2
mov ebx, [ebx]
mov cl, bl
mov ebx, 0
mov bl, cl
mov byte ptr[eax], bl
mov eax, 0
mov ebx, 0
ret


go_int:
cmp al,2
jne go_bool
mov eax, dword ptr var1
mov ebx, 0
mov ebx, dword ptr var2
mov ebx, [ebx]
mov dword ptr[eax], ebx
mov eax, 0
mov ebx, 0
ret


go_bool:
cmp al,3
jne go_string
mov eax, var1
mov ebx, 0
mov ebx, var2
mov ebx, [ebx]
mov cl, bl
mov ebx, 0
mov bl, cl
mov byte ptr[eax], bl
mov eax, 0
mov ebx, 0
ret


go_string:
cmp al,7
jne callError
cmp bl,7
jne callError
mov eax, var1
mov ebx, var2
copy:
    mov dl, [ebx] ; Load the current character from the string in var2 into dl
    mov [eax], dl ; Store the character in dl to the string in var1
    add eax, 1 ; Increment the pointer to var1
    add ebx, 1 ; Increment the pointer to var2
    cmp byte ptr [ebx], 0 ; Check if the end of the string in var2 is reached
	je next;
	cmp byte ptr [eax],0
    jne copy ; If not, continue to the next iteration
	next:
    ret

not_equal:

cmp bl, 1
jne callError
; int < -byte
	mov eax, dword ptr var1
	mov ebx, 0
	mov ebx, var2
	mov ebx, [ebx]
	mov cl, bl
	mov ebx, 0
	mov bl, cl
	mov dword ptr[eax], ebx
	mov eax, 0
	mov ebx, 0
	ret
	callError :
add current_string, 1
INVOKE int_to_char, OFFSET caption + 16, current_string
call showErrorMessageBox
Assign ENDP

#define ASSIGN_FUN "Assign PROC type1:ptr byte, var1:ptr byte, type2:ptr byte, var2:ptr byte\
\nSTART:\n\
mov eax, type1\n\
mov al, [eax]\n\
mov ebx, type2\n\
mov bl, [ebx]\n\
cmp al, bl\n\
jne not_equal\n\
\n\
not_equal :\n\
cmp al, 2\n\
jne callError\n\
cmp bl, 1\n\
jne callError\n\
; int < -byte\n\
	mov eax, dword ptr var1\n\
	mov ebx, 0\n\
	mov ebx, var2\n\
	mov ebx, [ebx]\n\
	mov cl, bl\n\
	mov ebx, 0\n\
	mov bl, cl\n\
	mov dword ptr[eax], ebx\n\
	mov eax, 0\n\
	mov ebx, 0\n\
	ret\n\
	callError :\n\
add current_string, 1\n\
INVOKE int_to_char, OFFSET caption + 16, current_string\n\
call showErrorMessageBox\n\
Assign ENDP\n"